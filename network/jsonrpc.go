package network

import (
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"time"
	"github.com/thrylos-labs/thrylos/crypto"

	"github.com/cloudflare/circl/sign/mldsa/mldsa44"
	"github.com/thrylos-labs/thrylos"
	"github.com/thrylos-labs/thrylos/amount"
	"github.com/thrylos-labs/thrylos/config"
	"github.com/thrylos-labs/thrylos/crypto/address"
	"github.com/thrylos-labs/thrylos/types"
)

// Handler struct now contains a messageBus instead of a direct node reference
type Handler struct {
	messageBus types.MessageBusInterface
}

// NewHandler creates a new Handler with the message bus
func NewHandler(messageBus types.MessageBusInterface) *Handler {
	return &Handler{messageBus: messageBus}
}

func sendJSONRPCError(w http.ResponseWriter, jsonrpcErr *JSONRPCError, id interface{}) {
	response := JSONRPCResponse{
		JSONRPC: "2.0",
		Error:   jsonrpcErr,
		ID:      id,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)
	json.NewEncoder(w).Encode(response)
}

type JSONRPCRequest struct {
	JSONRPC string        `json:"jsonrpc"`
	Method  string        `json:"method"`
	Params  []interface{} `json:"params"`
	ID      interface{}   `json:"id"`
}

type JSONRPCResponse struct {
	JSONRPC string        `json:"jsonrpc"`
	Result  interface{}   `json:"result,omitempty"`
	Error   *JSONRPCError `json:"error,omitempty"`
	ID      interface{}   `json:"id"`
}

type JSONRPCError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

// Main JSON-RPC handler that routes to appropriate handlers
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req JSONRPCRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendJSONRPCError(w, &JSONRPCError{
			Code:    -32700,
			Message: "Parse error",
		}, req.ID)
		return
	}

	var result interface{}
	var err error

	// REMEMBER THIS

	//  addresses aren't "registered" in the traditional sense. They simply exist
	//  once they're generated by a wallet, and they become
	//vVisible on the blockchain only when they're involved in transactions.

	// Check other JSON-RPC methods to make sure they're working as expected
	// Improve error handling to gracefully manage any future connection issues
	// Add features that utilize the blockchain data you're now able to retrieve

	// Only include core handlers
	switch req.Method {
	case "fundNewAddress":
		result, err = h.handleFundNewAddress(req.Params)
	case "getBalance":
		// - Check wallet balances
		result, err = h.handleGetBalance(req.Params)
	case "getUTXO":
		// Get transaction inputs for creating new transactions
		result, err = h.handleGetUTXO(req.Params)
	case "getBlock":
		//  - Get block details
		result, err = h.handleGetBlock(req.Params)
	case "getBlockchainInfo":
		//  - Get high-level blockchain information
		result, err = h.handleGetBlockchainInfo(req.Params)
	case "getBlockTransactions":
		// - Get transactions in a block
		result, err = h.handleGetBlockTransactions(req.Params)
	case "submitSignedTransaction":
		//  - Send transactions
		result, err = h.handleSubmitSignedTransaction(req.Params)
	case "estimateGas":
		// - Calculate transaction fees
		result, err = h.handleEstimateGas(req.Params)
	case "stake":
		//  Main entry point for staking actions
		result, err = h.handleStaking(req.Params)
	case "getStakingInfo":
		// - Get staking status information
		result, err = h.handleGetStakingInfo(req.Params)
	default:
		sendJSONRPCError(w, &JSONRPCError{
			Code:    -32601,
			Message: "Method not found",
		}, req.ID)
		return
	}

	if err != nil {
		sendJSONRPCError(w, &JSONRPCError{
			Code:    -32603,
			Message: err.Error(),
		}, req.ID)
		return
	}

	response := JSONRPCResponse{
		JSONRPC: "2.0",
		Result:  result,
		ID:      req.ID,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func (h *Handler) handleGetBalance(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("address parameter required")
	}

	address, ok := params[0].(string)
	if !ok {
		return nil, fmt.Errorf("invalid address parameter")
	}

	// First try the direct stakeholders lookup
	stakeholderCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakeholderBalance,
		Data:       address,
		ResponseCh: stakeholderCh,
	})

	// Wait for response
	stakeholderResp := <-stakeholderCh
	if stakeholderResp.Error == nil {
		if balance, ok := stakeholderResp.Data.(int64); ok {
			log.Printf("Found balance from stakeholders map for %s: %d", address, balance)
			return struct {
				Balance        int64   `json:"balance"`
				BalanceThrylos float64 `json:"balanceThrylos"`
			}{
				Balance:        balance,
				BalanceThrylos: float64(balance) / 1e7,
			}, nil
		}
	}

	// Fallback to original UTXO-based balance lookup
	responseCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetBalance,
		Data:       address,
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh
	log.Printf("DEBUG: handleGetBalance network handler received response: %+v", response)

	if response.Error != nil {
		log.Printf("Error getting balance for address %s: %v", address, response.Error)
		return struct {
			Balance        int64   `json:"balance"`
			BalanceThrylos float64 `json:"balanceThrylos"`
		}{
			Balance:        0,
			BalanceThrylos: 0,
		}, nil
	}

	balance, ok := response.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid balance data type")
	}

	return struct {
		Balance        int64   `json:"balance"`
		BalanceThrylos float64 `json:"balanceThrylos"`
	}{
		Balance:        balance,
		BalanceThrylos: float64(balance) / 1e7,
	}, nil
}

// Fund addresses from the genesis account or can it fund the address from the balance?

// Add this method to your Handler struct in Go
func (h *Handler) handleFundNewAddress(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("address parameter required")
	}

	address, ok := params[0].(string)
	if !ok {
		return nil, fmt.Errorf("invalid address parameter")
	}

	// Default amount: 70 THRYLOS in nano
	amountInt64 := int64(700000000)

	// If amount is specified as a second parameter, use that instead
	if len(params) > 1 {
		if amountParam, ok := params[1].(float64); ok {
			amountInt64 = int64(amountParam)
		}
	}

	// Convert int64 to amount.Amount
	// Using simple type casting since amount.Amount is a type alias for int64
	amountValue := amount.Amount(amountInt64)

	// Create response channel
	responseCh := make(chan types.Response)

	// Send message to fund new address
	h.messageBus.Publish(types.Message{
		Type: types.FundNewAddress,
		Data: types.FundAddressRequest{
			Address: address,
			Amount:  amountValue,
		},
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh
	if response.Error != nil {
		return nil, fmt.Errorf("error funding address: %v", response.Error)
	}

	return map[string]interface{}{
		"status":  "funded",
		"message": fmt.Sprintf("Address %s has been funded with %0.2f THRYLOS", address, float64(amountValue)/1e7),
		"amount":  float64(amountValue) / 1e7,
	}, nil
}

// handleGetUTXO now uses message bus
func (h *Handler) handleGetUTXO(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("address parameter required")
	}

	address, ok := params[0].(string)
	if !ok {
		return nil, fmt.Errorf("invalid address parameter")
	}

	log.Printf("Fetching UTXOs for address: %s", address)

	// Create response channel
	responseCh := make(chan types.Response)

	// Send message to get UTXOs
	h.messageBus.Publish(types.Message{
		Type: types.GetUTXOs,
		Data: types.UTXORequest{
			Address: address,
		},
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh

	if response.Error != nil {
		log.Printf("Error fetching UTXOs for address %s: %v", address, response.Error)
		return nil, fmt.Errorf("error fetching UTXOs: %v", response.Error)
	}

	// Convert response data to UTXOs
	utxos, ok := response.Data.([]types.UTXO)
	if !ok {
		return nil, fmt.Errorf("invalid UTXOs data type")
	}

	if len(utxos) == 0 {
		log.Printf("No UTXOs found for address: %s", address)
		return []interface{}{}, nil // Empty array instead of error for JSON-RPC
	}

	// Log UTXOs for debugging
	for i, utxo := range utxos {
		log.Printf("UTXO %d for address %s: {ID: %s, TransactionID: %s, Index: %d, Amount: %d, IsSpent: %v}",
			i, address, utxo.ID, utxo.TransactionID, utxo.Index, utxo.Amount, utxo.IsSpent)
	}

	return utxos, nil
}

// Add this method to your Handler struct in the network package

// handleGetBlock handles JSON-RPC requests to get block information
// Add this method to your Handler struct in the network package

// handleGetBlock handles JSON-RPC requests to get block information
func (h *Handler) handleGetBlock(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("block identifier required")
	}

	// Create response channel
	responseCh := make(chan types.Response)

	// Handle both string (hash) and number (height) parameters
	var messageData interface{}
	switch v := params[0].(type) {
	case string:
		messageData = v // block hash
	case float64:
		messageData = int32(v) // block height
	default:
		return nil, fmt.Errorf("invalid block identifier type")
	}

	// Send message to get block using ProcessBlock message type
	h.messageBus.Publish(types.Message{
		Type:       types.ProcessBlock, // Use existing ProcessBlock type
		Data:       messageData,
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh

	if response.Error != nil {
		return nil, fmt.Errorf("block not found: %v", response.Error)
	}

	// Convert response data to Block
	block, ok := response.Data.(*types.Block)
	if !ok {
		return nil, fmt.Errorf("invalid block data type")
	}

	if block.Transactions == nil {
		log.Printf("No transactions found in block %v", params[0])
	}

	return block, nil
}

// handleGetBlock now uses message bus
func (h *Handler) handleGetBlockchainInfo(params []interface{}) (interface{}, error) {
	// Create a single response channel
	infoCh := make(chan types.Response)

	// Request all blockchain info at once
	h.messageBus.Publish(types.Message{
		Type:       types.GetBlockchainInfo,
		Data:       nil, // No specific data needed
		ResponseCh: infoCh,
	})

	// Wait for response with timeout
	select {
	case resp := <-infoCh:
		if resp.Error != nil {
			return nil, resp.Error
		}
		return resp.Data, nil
	case <-time.After(5 * time.Second):
		return map[string]interface{}{
			"height":      0,
			"chainId":     "thrylos-testnet",
			"lastBlock":   "",
			"nodeCount":   0,
			"nodeVersion": "1.0.0",
			"isSyncing":   false,
		}, fmt.Errorf("timeout waiting for blockchain info")
	}
}

func (h *Handler) handleGetBlockTransactions(params []interface{}) (interface{}, error) {
	// Check if params exist
	if len(params) < 1 {
		return nil, fmt.Errorf("block ID parameter required")
	}

	// Extract blockID from params
	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format")
	}

	blockID, ok := reqData["blockId"].(string)
	if !ok {
		return nil, fmt.Errorf("blockId required")
	}

	// Create response channel
	blockCh := make(chan types.Response)

	// Send message to get block
	h.messageBus.Publish(types.Message{
		Type:       types.ProcessBlock,
		Data:       blockID,
		ResponseCh: blockCh,
	})

	// Wait for response
	blockResp := <-blockCh

	if blockResp.Error != nil {
		return nil, fmt.Errorf("block not found: %v", blockResp.Error)
	}

	// Convert response data to Block
	block, ok := blockResp.Data.(*types.Block)
	if !ok {
		return nil, fmt.Errorf("invalid block data type")
	}

	// Return transactions with additional metadata
	return map[string]interface{}{
		"blockId":          blockID,
		"transactionCount": len(block.Transactions),
		"transactions":     block.Transactions,
	}, nil
}

const MinTransactionAmount int64 = 1 * config.NanoPerThrylos // 1 THRYLOS in nanoTHRYLOS

// Helper function (add if not present)
func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func (h *Handler) handleSubmitSignedTransaction(params []interface{}) (interface{}, error) {
	// Check if params exist
	if len(params) < 1 {
		return nil, fmt.Errorf("transaction parameter required")
	}

	// Extract the request data map
	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format, expected JSON object in params[0]")
	}

	// --- Extract payload map ---
	payload, ok := reqData["payload"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid or missing 'payload' object in request data")
	}

	// --- Extract other required fields ---
	signatureString, ok := reqData["signature"].(string)
	if !ok { return nil, fmt.Errorf("invalid or missing 'signature' string") }
	publicKeyString, ok := reqData["publicKey"].(string)
	if !ok { return nil, fmt.Errorf("invalid or missing 'publicKey' string") }
	payloadString, ok := reqData["payloadString"].(string)
	if !ok { return nil, fmt.Errorf("invalid or missing 'payloadString' string") }

	// --- Extract necessary info from ORIGINAL payload for intent ---
	sender, ok := payload["sender"].(string)
	if !ok || sender == "" { return nil, fmt.Errorf("invalid or missing 'sender' in payload") }
	idStr, ok := payload["id"].(string)
	if !ok || idStr == "" { return nil, fmt.Errorf("invalid or missing 'id' in payload") }
	gasFeeFloat, ok := payload["gasfee"].(float64)
	if !ok { return nil, fmt.Errorf("invalid or missing 'gasfee' in payload") }
	gasFee := int(gasFeeFloat) // Store as int matching types.Transaction
	timestampFloat, ok := payload["timestamp"].(float64)
	if !ok { return nil, fmt.Errorf("invalid or missing 'timestamp' in payload") }
	timestamp := int64(timestampFloat)

	// Extract intended recipient and amount from ORIGINAL payload outputs
	// NOTE: This assumes the structure sent by the frontend.
	// We IGNORE the frontend's change output calculation.
	var recipientAddress string
	var amountToSendNano int64 // Amount intended for the primary recipient
	payloadOutputs, ok := payload["outputs"].([]interface{})
	if !ok || len(payloadOutputs) == 0 { return nil, fmt.Errorf("invalid or missing 'outputs' in payload") }

	// Assume first output is the primary recipient
	firstOutputMap, ok := payloadOutputs[0].(map[string]interface{})
	if !ok { return nil, fmt.Errorf("invalid format for first output in payload") }
	recipientAddress, ok = firstOutputMap["OwnerAddress"].(string)
	if !ok || recipientAddress == "" { return nil, fmt.Errorf("invalid or missing 'OwnerAddress' in first output") }
	amountFloat, ok := firstOutputMap["Amount"].(float64)
	if !ok { return nil, fmt.Errorf("invalid or missing 'Amount' in first output") }
	amountToSendNano = int64(amountFloat)

	log.Printf("INFO: Intent: Send %d nanoTHR from %s to %s (TxID: %s, Fee: %d)", amountToSendNano, sender, recipientAddress, idStr, gasFee)


	// --- Validation Goroutine ---
	// Modification: Need to get pkBytes back for populating transactionData later
	type validationResult struct {
		 SignatureBytes []byte
		 PublicKeyBytes []byte
		 Err            error
	}
	validationDone := make(chan validationResult, 1)

	go func() {
		var vr validationResult // Result to send back
		var pk *mldsa44.PublicKey // Keep the unmarshalled key

		// Decode Public Key
		vr.PublicKeyBytes, vr.Err = base64.StdEncoding.DecodeString(publicKeyString)
		if vr.Err != nil { vr.Err = fmt.Errorf("invalid public key encoding: %v", vr.Err); validationDone <- vr; return }
		log.Println("TX_VALIDATE: Decoded PK Bytes (first 16):", hex.EncodeToString(vr.PublicKeyBytes[:min(16, len(vr.PublicKeyBytes))]))

		// Unmarshal Public Key
		pk = new(mldsa44.PublicKey)
		if vr.Err = pk.UnmarshalBinary(vr.PublicKeyBytes); vr.Err != nil {
			log.Printf("TX_VALIDATE_ERROR: Failed to unmarshal public key: %v", vr.Err)
			vr.Err = fmt.Errorf("failed to unmarshal public key: %v", vr.Err); validationDone <- vr; return
		}
		log.Printf("TX_VALIDATE_INFO: Successfully unmarshalled public key")

		// Derive Address
		derivedAddress, err := address.ConvertToBech32Address(pk)
		if err != nil {
			log.Printf("TX_VALIDATE_ERROR: Failed to derive address: %v", err)
			vr.Err = fmt.Errorf("failed to derive address: %v", err); validationDone <- vr; return
		}
		log.Printf("TX_VALIDATE_INFO: Derived Address: %s", derivedAddress)

		// Verify Sender Address
		if derivedAddress != sender {
			log.Printf("TX_VALIDATE_ERROR: Address mismatch! Derived: %s, Claimed: %s", derivedAddress, sender)
			vr.Err = fmt.Errorf("public key does not match sender address: derived=%s, claimed=%s", derivedAddress, sender)
			validationDone <- vr; return
		}
		log.Println("TX_VALIDATE_INFO: Sender address matches derived address.")

		// --- Signature Verification ---
		// Decode signature
		vr.SignatureBytes, vr.Err = base64.StdEncoding.DecodeString(signatureString)
		if vr.Err != nil { vr.Err = fmt.Errorf("invalid signature encoding: %v", vr.Err); validationDone <- vr; return }
		if len(vr.SignatureBytes) != mldsa44.SignatureSize {
			log.Printf("TX_VALIDATE_ERROR: Sig size mismatch: got %d, want %d", len(vr.SignatureBytes), mldsa44.SignatureSize)
			vr.Err = fmt.Errorf("decoded signature has incorrect size"); validationDone <- vr; return
		}
		log.Printf("TX_VALIDATE: Decoded Signature Length: %d", len(vr.SignatureBytes))

		// Verify Signature against ORIGINAL payload string
		messageBytes := []byte(payloadString)
		log.Println("TX_VALIDATE: Using Payload String for verification:", payloadString)
		ctxForVerify := []byte(nil)
		isValid := mldsa44.Verify(pk, messageBytes, ctxForVerify, vr.SignatureBytes)
		log.Printf("TX_VALIDATE_INFO: Signature verification result: %v", isValid)

		if !isValid {
			log.Printf("TX_VALIDATE_ERROR: Signature verification FAILED!")
			vr.Err = fmt.Errorf("invalid signature"); validationDone <- vr; return
		}

		log.Printf("TX_VALIDATE_SUCCESS: Signature verified successfully!")
		vr.Err = nil // Explicitly set error to nil on success
		validationDone <- vr // Signal success
	}() // End of goroutine


	// --- Wait for Validation Result ---
	var validationRes validationResult
	select {
	case validationRes = <-validationDone:
		if validationRes.Err != nil {
			log.Printf("Validation failed: %v", validationRes.Err)
			return nil, validationRes.Err // Return the validation error
		}
	case <-time.After(5 * time.Second):
		log.Println("Validation timeout occurred")
		return nil, fmt.Errorf("validation timeout")
	}
	// --- Validation Successful ---
	log.Println("Validation completed successfully.")
	finalSignatureBytes := validationRes.SignatureBytes // Keep original signature
	finalPublicKeyBytes := validationRes.PublicKeyBytes // Keep original public key bytes


	// --- Fetch Sender's REAL UTXOs ---
	log.Printf("INFO: Fetching UTXOs for sender %s", sender)
	utxoResponseCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type: types.GetUTXOs,
		Data: types.UTXORequest{ Address: sender },
		ResponseCh: utxoResponseCh,
	})

	var utxoResponse types.Response
	select {
	case utxoResponse = <-utxoResponseCh:
		if utxoResponse.Error != nil {
			log.Printf("ERROR: Failed to fetch UTXOs for %s: %v", sender, utxoResponse.Error)
			return nil, fmt.Errorf("failed to fetch UTXOs: %v", utxoResponse.Error)
		}
	case <-time.After(5 * time.Second): // Timeout for UTXO fetch
		log.Printf("ERROR: Timeout fetching UTXOs for %s", sender)
		return nil, fmt.Errorf("timeout fetching UTXOs")
	}

	availableUTXOs, ok := utxoResponse.Data.([]types.UTXO)
	if !ok {
		log.Printf("ERROR: Invalid UTXO data type received for %s", sender)
		return nil, fmt.Errorf("invalid UTXO data type received")
	}
	log.Printf("INFO: Found %d UTXOs for sender %s", len(availableUTXOs), sender)


	// --- UTXO Selection ---
	amountNeeded := amountToSendNano + int64(gasFee)
	var selectedUTXOs []types.UTXO
	var selectedTotal int64 = 0

	// Optional: Sort available UTXOs (e.g., smallest first to consolidate, or largest first)
	// sort.Slice(availableUTXOs, func(i, j int) bool {
	// 	return availableUTXOs[i].Amount < availableUTXOs[j].Amount
	// })

	for _, utxo := range availableUTXOs {
		if !utxo.IsSpent { // Ensure we only consider unspent ones
			selectedUTXOs = append(selectedUTXOs, utxo)
			selectedTotal += int64(utxo.Amount) // Assuming utxo.Amount is amount.Amount (int64)
			log.Printf("DEBUG: Selected UTXO %s-%d (Amount: %d), Total selected: %d", utxo.TransactionID, utxo.Index, utxo.Amount, selectedTotal)
			if selectedTotal >= amountNeeded {
				break // Found enough value
			}
		}
	}

	if selectedTotal < amountNeeded {
		log.Printf("ERROR: Insufficient funds for %s. Needed: %d, Available in UTXOs: %d", sender, amountNeeded, selectedTotal)
		return nil, fmt.Errorf("insufficient funds. Needed %d nanoTHR, have %d nanoTHR in available UTXOs", amountNeeded, selectedTotal)
	}
	log.Printf("INFO: Selected %d UTXOs with total value %d nanoTHR for amount %d + fee %d", len(selectedUTXOs), selectedTotal, amountToSendNano, gasFee)


	// --- Calculate Change ---
	changeAmount := selectedTotal - amountNeeded
	log.Printf("INFO: Calculated change: %d nanoTHR", changeAmount)


	// --- Construct Transaction Data with REAL Inputs/Outputs ---
	var transactionData types.Transaction
	transactionData.ID = idStr
	transactionData.Timestamp = timestamp
	senderAddr, _ := address.FromString(sender) // Already validated sender string
	transactionData.SenderAddress = *senderAddr
	transactionData.GasFee = gasFee
	// --- Assign REAL Inputs ---
	transactionData.Inputs = selectedUTXOs // Assign the selected UTXOs
	// --- Create REAL Outputs ---
	transactionData.Outputs = []types.UTXO{}
	// Output to recipient
	transactionData.Outputs = append(transactionData.Outputs, types.UTXO{
		OwnerAddress: recipientAddress,
		Amount:       amount.Amount(amountToSendNano), // Cast to amount.Amount
		Index:        0, // Index for outputs within this tx
		// TransactionID will be set by processing handler/block creation typically
	})
	// Output for change (if any)
	if changeAmount > 0 {
		transactionData.Outputs = append(transactionData.Outputs, types.UTXO{
			OwnerAddress: sender, // Change goes back to sender
			Amount:       amount.Amount(changeAmount), // Cast to amount.Amount
			Index:        1, // Next index
		})
	}
	
	log.Printf("DEBUG: [handleSubmit] finalPublicKeyBytes Length: %d", len(finalPublicKeyBytes))
// Log first and last few bytes to see if anything looks odd
log.Printf("DEBUG: [handleSubmit] finalPublicKeyBytes Hex (first 32): %x", finalPublicKeyBytes[:min(32, len(finalPublicKeyBytes))])
log.Printf("DEBUG: [handleSubmit] finalPublicKeyBytes Hex (last 32): %x", finalPublicKeyBytes[max(0, len(finalPublicKeyBytes)-32):])


    senderPubKey, err := crypto.NewPublicKeyFromBytes(finalPublicKeyBytes) // <<< FIX: Use correct function name
    if err != nil {
        log.Printf("ERROR: Failed to reconstruct sender public key from bytes for tx data: %v", err)
        // Decide if this is fatal. If the public key is needed later, it probably is.
        return nil, fmt.Errorf("failed to reconstruct sender public key: %v", err)
    }
    // Also check if the function returned a nil interface value, even without error
    if senderPubKey == nil {
         log.Printf("ERROR: Reconstructed sender public key is nil for tx %s, though NewPublicKeyFromBytes returned no error.", idStr)
         return nil, fmt.Errorf("reconstructed sender public key is unexpectedly nil")
    }

    // Assign the crypto.PublicKey interface value to the transaction data
    transactionData.SenderPublicKey = senderPubKey
    log.Printf("DEBUG: Reconstructed and assigned SenderPublicKey to transactionData")

	// --- Convert to final Thrylos transaction type ---
	// NOTE: convertToThrylosTransaction needs to correctly handle the REAL inputs/outputs now
	thrylosTx := convertToThrylosTransaction(&transactionData)
	if thrylosTx == nil {
		return nil, fmt.Errorf("failed to convert to final transaction type")
	}
	// --- Attach ORIGINAL Signature ---
	// This signature does NOT match the *new* tx structure but is kept for now.
	thrylosTx.Signature = finalSignatureBytes
	log.Printf("WARN: Attaching original signature to structurally different transaction. Re-signing needed for full validity.")


	log.Printf("DEBUG: [handleSubmitSignedTransaction] Sending CORRECTED tx %s to bus. Sender: %q, Inputs: %d, Outputs: %d", thrylosTx.Id, thrylosTx.Sender, len(thrylosTx.Inputs), len(thrylosTx.Outputs))

	// --- Process Transaction via Message Bus ---
	processTxCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.ProcessTransaction,
		Data:       thrylosTx, // Send the transaction with REAL inputs/outputs
		ResponseCh: processTxCh,
	})

	// --- Wait for processing response ---
	var processTxResponse types.Response
	select {
	case processTxResponse = <-processTxCh:
		if processTxResponse.Error != nil {
			log.Printf("Transaction processing failed for %s: %v", thrylosTx.GetId(), processTxResponse.Error)
			// Provide more context if the error is about UTXOs not found, as it might indicate state issues
			return nil, fmt.Errorf("failed to process transaction: %v", processTxResponse.Error)
		}
		log.Printf("Transaction %s processed successfully by message bus.", thrylosTx.GetId())
	case <-time.After(10 * time.Second):
		log.Printf("Transaction processing timeout for %s", thrylosTx.GetId())
		return nil, fmt.Errorf("transaction processing timeout")
	}


	// --- Remove background balance update ---
	// This background update is likely unreliable and unnecessary if ProcessTransaction updates state correctly.
	/*
	go func() { ... }()
	*/


	// --- Return Success ---
	log.Printf("Successfully submitted transaction %s (pending final processing)", transactionData.ID)
	return struct {
		Message string `json:"message"`
		Status  string `json:"status"`
		TxID    string `json:"txId"`
	}{
		Message: fmt.Sprintf("Transaction %s submitted successfully", transactionData.ID),
		Status:  "submitted", // Changed status to reflect it's sent for processing
		TxID:    transactionData.ID,
	}, nil
}


// Helper function to convert types.Transaction to *thrylos.Transaction (protobuf)
func convertToThrylosTransaction(tx *types.Transaction) *thrylos.Transaction {
	if tx == nil {
		log.Printf("ERROR: [convertToThrylosTransaction] called with nil input")
		return nil
	}

	senderStr := tx.SenderAddress.String()
	log.Printf("DEBUG: [convertToThrylosTransaction] Input tx.ID: %s, Sender: %q", tx.ID, senderStr)

	thrylosTx := &thrylos.Transaction{
		Id:        tx.ID,
		Sender:    senderStr,
		Timestamp: tx.Timestamp,
		Status:    "pending",
		Gasfee:    int32(tx.GasFee),
		// SenderPublicKey: tx.SenderPublicKey.Bytes(), // <<< REMOVE direct assignment here
	}

	// --- Handle SenderPublicKey Safely --- <<< ADD THIS BLOCK
	if tx.SenderPublicKey != nil {
		// Assuming crypto.PublicKey has a Marshal() method that returns []byte, error
		// Or a Bytes() method that returns []byte. Adjust accordingly.
		pubKeyBytes, err := tx.SenderPublicKey.Marshal() // Or .Bytes()
		if err != nil {
			// Log the error but maybe don't stop the whole conversion? Or return nil?
			log.Printf("ERROR: [convertToThrylosTransaction] Failed to marshal SenderPublicKey for tx %s: %v", tx.ID, err)
			// Depending on requirements, you might 'return nil' here if PK is essential
		} else if len(pubKeyBytes) > 0 {
			thrylosTx.SenderPublicKey = pubKeyBytes // Assign ONLY if not nil and marshaled ok
			log.Printf("DEBUG: [convertToThrylosTransaction] Assigned SenderPublicKey bytes (len %d)", len(pubKeyBytes))
		} else {
            log.Printf("WARN: [convertToThrylosTransaction] SenderPublicKey marshalled to empty bytes for tx %s", tx.ID)
        }
	} else {
		log.Printf("WARN: [convertToThrylosTransaction] Input tx.SenderPublicKey is nil for tx %s.", tx.ID)
		// thrylosTx.SenderPublicKey will remain its zero value (likely nil or empty slice)
	}
	// --- End Handle SenderPublicKey ---

	// --- Convert Inputs --- (Ensure this logic is correct from previous steps)
	if len(tx.Inputs) > 0 {
		thrylosTx.Inputs = make([]*thrylos.UTXO, len(tx.Inputs))
		log.Printf("DEBUG: [convertToThrylosTransaction] Converting %d inputs for tx %s", len(tx.Inputs), tx.ID)
		for i, inputUtxo := range tx.Inputs {
			thrylosTx.Inputs[i] = convertTypesUTXOToProtoUTXO(inputUtxo)
		}
	} else { /* Assign empty slice */ thrylosTx.Inputs = []*thrylos.UTXO{} }


	// --- Convert Outputs --- (Ensure this logic is correct from previous steps)
	if len(tx.Outputs) > 0 {
		thrylosTx.Outputs = make([]*thrylos.UTXO, len(tx.Outputs))
		log.Printf("DEBUG: [convertToThrylosTransaction] Converting %d outputs for tx %s", len(tx.Outputs), tx.ID)
		for i, outputUtxo := range tx.Outputs {
			thrylosTx.Outputs[i] = convertTypesUTXOToProtoUTXO(outputUtxo)
		}
	} else { /* Assign empty slice */ thrylosTx.Outputs = []*thrylos.UTXO{} }


	// TODO: Assign other fields like Signature safely (with nil checks) if needed

	log.Printf("DEBUG: [convertToThrylosTransaction] Returning thrylosTx. Sender: %q, Inputs: %d, Outputs: %d, PK Len: %d", thrylosTx.Sender, len(thrylosTx.Inputs), len(thrylosTx.Outputs), len(thrylosTx.SenderPublicKey))
	return thrylosTx
}

// Ensure convertTypesUTXOToProtoUTXO exists and is correct
func convertTypesUTXOToProtoUTXO(typeUtxo types.UTXO) *thrylos.UTXO {
    // ... implementation ...
	return &thrylos.UTXO{
		 TransactionId: typeUtxo.TransactionID,
		 Index:         int32(typeUtxo.Index),
		 OwnerAddress:  typeUtxo.OwnerAddress,
		 Amount:        int64(typeUtxo.Amount),
		 IsSpent:       typeUtxo.IsSpent,
	}
}


func (h *Handler) handleEstimateGas(params []interface{}) (interface{}, error) {
	// Log the incoming request
	log.Printf("estimateGas JSON-RPC method called")

	// Check if params exist
	if len(params) < 1 {
		return nil, fmt.Errorf("dataSize parameter required")
	}

	// Extract dataSize from params
	dataSizeFloat, ok := params[0].(float64)
	if !ok {
		return nil, fmt.Errorf("invalid dataSize parameter: must be a number")
	}

	// Convert float64 to int
	dataSize := int(dataSizeFloat)

	// Create response channel
	responseCh := make(chan types.Response)

	// Send message to estimate gas
	h.messageBus.Publish(types.Message{
		Type: types.EstimateGas, // Now defined
		Data: map[string]interface{}{
			"dataSize": dataSize,
			"txType":   0, // Default transaction type
		},
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh

	if response.Error != nil {
		return nil, fmt.Errorf("error estimating gas: %v", response.Error)
	}

	// Convert response data to gas fee
	gas, ok := response.Data.(int)
	if !ok {
		return nil, fmt.Errorf("invalid gas fee data type")
	}

	// Log the estimation
	log.Printf("Gas fee estimate calculated: %d for data size: %d", gas, dataSize)

	// Return structured response
	return struct {
		GasFee     int    `json:"gasFee"`
		GasFeeUnit string `json:"gasFeeUnit"`
	}{
		GasFee:     gas,
		GasFeeUnit: "nanoTHRYLOS",
	}, nil
}

// Main handler for staking operations
func (h *Handler) handleStaking(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("parameters required")
	}

	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format")
	}

	// Extract operation type
	operation, ok := reqData["operation"].(string)
	if !ok {
		return nil, fmt.Errorf("operation field required")
	}

	switch operation {
	case "stake":
		return h.handleStakeOperation(reqData)
	case "validate":
		return h.handleValidateStakeOperation(reqData)
	default:
		return nil, fmt.Errorf("unknown operation: %s", operation)
	}
}

func (h *Handler) handleStakeOperation(reqData map[string]interface{}) (interface{}, error) {
	// Extract required fields
	userAddress, ok := reqData["userAddress"].(string)
	if !ok {
		return nil, fmt.Errorf("userAddress required")
	}

	amountFloat, ok := reqData["amount"].(float64)
	if !ok {
		return nil, fmt.Errorf("amount required")
	}
	amount := int64(amountFloat)

	validatorAddress, ok := reqData["validatorAddress"].(string)
	if !ok {
		return nil, fmt.Errorf("validatorAddress required")
	}

	// Create response channels for various operations
	minStakeCh := make(chan types.Response)
	validatorExistsCh := make(chan types.Response)
	balanceCh := make(chan types.Response)
	createStakeCh := make(chan types.Response)

	// Get minimum stake amount
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       "minStakeAmount",
		ResponseCh: minStakeCh,
	})

	// Check if validator exists and is active
	h.messageBus.Publish(types.Message{
		Type: types.ValidateValidator,
		Data: map[string]interface{}{
			"address": validatorAddress,
		},
		ResponseCh: validatorExistsCh,
	})

	// Get user balance
	h.messageBus.Publish(types.Message{
		Type:       types.GetBalance,
		Data:       userAddress,
		ResponseCh: balanceCh,
	})

	// Wait for responses
	minStakeResp := <-minStakeCh
	validatorResp := <-validatorExistsCh
	balanceResp := <-balanceCh

	// Process responses
	if minStakeResp.Error != nil {
		return nil, fmt.Errorf("failed to get minimum stake: %v", minStakeResp.Error)
	}
	minStake, ok := minStakeResp.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid minimum stake data type")
	}

	// Validate minimum stake
	if amount < minStake {
		return nil, fmt.Errorf("stake amount must be at least %d THRYLOS", minStake/1e7)
	}

	// Validate validator exists and is active
	if validatorResp.Error != nil || validatorResp.Data == nil {
		return nil, fmt.Errorf("invalid validator address")
	}
	validatorExists, ok := validatorResp.Data.(bool)
	if !ok || !validatorExists {
		return nil, fmt.Errorf("validator does not exist or is not active")
	}

	// Check user's balance
	if balanceResp.Error != nil {
		return nil, fmt.Errorf("failed to get balance: %v", balanceResp.Error)
	}
	balance, ok := balanceResp.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid balance data type")
	}

	if balance < amount+1000 { // Including gas fee
		return nil, fmt.Errorf("insufficient balance for staking")
	}

	// Create stake record via message bus
	h.messageBus.Publish(types.Message{
		Type: types.CreateStake,
		Data: map[string]interface{}{
			"userAddress": userAddress,
			"amount":      amount,
			"validator":   validatorAddress,
		},
		ResponseCh: createStakeCh,
	})

	// Wait for stake creation response
	createStakeResp := <-createStakeCh
	if createStakeResp.Error != nil {
		return nil, fmt.Errorf("failed to create stake: %v", createStakeResp.Error)
	}

	// Get stake record from response
	stakeRecord, ok := createStakeResp.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid stake record data type")
	}

	// Create staking transaction ID
	stakingTxId := fmt.Sprintf("stake-%s-%d", userAddress, time.Now().UnixNano())

	// Get inflation rate for response
	effectiveRateCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       "effectiveRate",
		ResponseCh: effectiveRateCh,
	})
	effectiveRateResp := <-effectiveRateCh
	effectiveRate := "4.8%"
	if effectiveRateResp.Error == nil {
		if rate, ok := effectiveRateResp.Data.(float64); ok {
			effectiveRate = fmt.Sprintf("%.2f%%", rate)
		}
	}

	// Get staking pool info for last reward time
	poolInfoCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetPoolStats,
		Data:       nil,
		ResponseCh: poolInfoCh,
	})
	poolInfoResp := <-poolInfoCh

	// Extract last reward time and calculate next reward time
	lastRewardTime := time.Now().Unix()
	if poolInfoResp.Error == nil {
		if poolInfo, ok := poolInfoResp.Data.(map[string]interface{}); ok {
			if lrt, ok := poolInfo["lastRewardTime"].(int64); ok {
				lastRewardTime = lrt
			}
		}
	}
	nextRewardTime := lastRewardTime + (24 * 3600) // 24 hours in seconds

	// Get active validators count
	validatorsCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetValidators,
		Data:       nil,
		ResponseCh: validatorsCh,
	})
	validatorsResp := <-validatorsCh
	activeValidatorsCount := 1
	if validatorsResp.Error == nil {
		if validators, ok := validatorsResp.Data.([]interface{}); ok {
			activeValidatorsCount = len(validators)
		}
	}

	// Format response
	return map[string]interface{}{
		"message": "Stake created successfully",
		"stake": map[string]interface{}{
			"amount":         float64(amount) / 1e7,
			"amountRaw":      amount,
			"startTime":      stakeRecord["startTime"],
			"isActive":       stakeRecord["isActive"],
			"validatorRole":  stakeRecord["validatorRole"],
			"lastRewardTime": lastRewardTime,
		},
		"transactionId": stakingTxId,
		"stakingInfo": map[string]interface{}{
			"yearlyReward":         "4.8M",
			"effectiveRate":        effectiveRate,
			"minStakeAmount":       float64(minStake) / 1e7,
			"nextRewardTime":       nextRewardTime,
			"rewardInterval":       "24h",
			"activeValidators":     activeValidatorsCount,
			"estimatedDailyReward": 4800000.0 / 365.0 / float64(activeValidatorsCount) / 1e7,
		},
	}, nil
}

func (h *Handler) handleValidateStakeOperation(reqData map[string]interface{}) (interface{}, error) {
	amountFloat, ok := reqData["amount"].(float64)
	if !ok {
		return nil, fmt.Errorf("amount required")
	}
	amount := int64(amountFloat)

	// Get minimum stake amount
	minStakeCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       "minStakeAmount",
		ResponseCh: minStakeCh,
	})

	// Wait for response
	minStakeResp := <-minStakeCh
	if minStakeResp.Error != nil {
		return nil, fmt.Errorf("failed to get minimum stake: %v", minStakeResp.Error)
	}

	minStake, ok := minStakeResp.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid minimum stake data type")
	}

	if amount < minStake {
		return nil, fmt.Errorf("minimum stake is %d THR", minStake/1e7)
	}

	return map[string]interface{}{
		"valid": true,
	}, nil
}

func (h *Handler) handleGetStakingInfo(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("address parameter required")
	}

	// Extract address
	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format")
	}

	userAddress, ok := reqData["address"].(string)
	if !ok {
		return nil, fmt.Errorf("address parameter required")
	}

	// Create response channels
	stakingInfoCh := make(chan types.Response)
	poolInfoCh := make(chan types.Response)
	validatorCh := make(chan types.Response)

	// Send requests in parallel
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       userAddress,
		ResponseCh: stakingInfoCh,
	})

	h.messageBus.Publish(types.Message{
		Type:       types.GetPoolStats,
		Data:       nil,
		ResponseCh: poolInfoCh,
	})

	h.messageBus.Publish(types.Message{
		Type: types.IsValidator,
		Data: map[string]interface{}{
			"address": userAddress,
		},
		ResponseCh: validatorCh,
	})

	// Collect responses
	stakingInfoResp := <-stakingInfoCh
	poolInfoResp := <-poolInfoCh
	validatorResp := <-validatorCh

	// Initialize with default values
	totalStaked := int64(0)
	totalRewards := int64(0)
	isValidator := false
	activeStakes := make([]*types.Stake, 0)
	currentTime := time.Now().Unix()
	nextRewardTime := currentTime + (24 * 3600)
	stakingPool := map[string]interface{}{
		"minStakeAmount": int64(10000000000), // 1000 THR in nano
		"totalStaked":    int64(0),
		"lastRewardTime": currentTime - (12 * 3600), // 12 hours ago
	}

	// Process staking info response
	if stakingInfoResp.Error == nil {
		if info, ok := stakingInfoResp.Data.(map[string]interface{}); ok {
			if ts, ok := info["totalStaked"].(int64); ok {
				totalStaked = ts
			} else if tsMap, ok := info["totalStaked"].(map[string]interface{}); ok {
				if nano, ok := tsMap["nano"].(int64); ok {
					totalStaked = nano
				}
			}

			if tr, ok := info["totalRewards"].(int64); ok {
				totalRewards = tr
			} else if trMap, ok := info["totalRewards"].(map[string]interface{}); ok {
				if nano, ok := trMap["nano"].(int64); ok {
					totalRewards = nano
				}
			}

			if stakes, ok := info["activeStakes"].([]types.Stake); ok {
				for _, stake := range stakes {
					activeStakes = append(activeStakes, &stake)
				}
			}
		}
	}

	// Process pool info response
	if poolInfoResp.Error == nil {
		if pool, ok := poolInfoResp.Data.(map[string]interface{}); ok {
			if minStake, ok := pool["minStakeAmount"].(int64); ok {
				stakingPool["minStakeAmount"] = minStake
			}

			if totalPoolStake, ok := pool["totalStaked"].(int64); ok {
				stakingPool["totalStaked"] = totalPoolStake
			}

			if lastRewardTime, ok := pool["lastRewardTime"].(int64); ok {
				stakingPool["lastRewardTime"] = lastRewardTime
				nextRewardTime = lastRewardTime + (24 * 3600)
			}
		}
	}

	// Process validator response
	if validatorResp.Error == nil {
		if v, ok := validatorResp.Data.(bool); ok {
			isValidator = v
		}
	}

	// Calculate time until next reward
	lastRewardTime, _ := stakingPool["lastRewardTime"].(int64)
	timeUntilNextReward := (lastRewardTime + 24*3600) - currentTime
	if timeUntilNextReward < 0 {
		timeUntilNextReward = 0
	}

	// Return structured response
	return map[string]interface{}{
		"address":     userAddress,
		"isValidator": isValidator,
		"staking": map[string]interface{}{
			"totalStaked": map[string]interface{}{
				"thrylos": float64(totalStaked) / 1e7,
				"nano":    totalStaked,
			},
			"totalRewards": map[string]interface{}{
				"thrylos": float64(totalRewards) / 1e7,
				"nano":    totalRewards,
			},
			"activeStakesCount": len(activeStakes),
			"activeStakes":      activeStakes,
			"nextRewardTime":    nextRewardTime,
		},
		"stakingPool": map[string]interface{}{
			"minStakeAmount": map[string]interface{}{
				"thrylos": float64(stakingPool["minStakeAmount"].(int64)) / 1e7,
				"nano":    stakingPool["minStakeAmount"].(int64),
			},
			"totalStaked": map[string]interface{}{
				"thrylos": float64(stakingPool["totalStaked"].(int64)) / 1e7,
				"nano":    stakingPool["totalStaked"].(int64),
			},
			"rewardSchedule": map[string]interface{}{
				"interval":             "24h",
				"lastRewardTime":       lastRewardTime,
				"nextRewardTime":       nextRewardTime,
				"timeUntilNextReward":  timeUntilNextReward,
				"estimatedDailyReward": float64(4800000) / 365.0 / 10.0 / 1e7, // Assuming 10 validators
			},
			"rewardInfo": map[string]interface{}{
				"yearlyReward":       "4.8M",
				"effectiveRate":      "4.8%",
				"rewardDistribution": "Daily",
			},
		},
	}, nil
}

/// Get Balance test curl
// curl -X POST http://localhost:50051/ \
//   -H "Content-Type: application/json" \
//   -d '{"jsonrpc":"2.0","method":"getBalance","params":["tl1839b4955945b1607"],"id":1}' \
//   -v
