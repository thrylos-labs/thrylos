package network

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/btcsuite/btcutil/bech32"
	"github.com/cloudflare/circl/sign/mldsa/mldsa44"
	"github.com/thrylos-labs/thrylos"
	"github.com/thrylos-labs/thrylos/config"
	"github.com/thrylos-labs/thrylos/crypto/address"
	"github.com/thrylos-labs/thrylos/types"
)

// Handler struct now contains a messageBus instead of a direct node reference
type Handler struct {
	messageBus types.MessageBusInterface
}

// NewHandler creates a new Handler with the message bus
func NewHandler(messageBus types.MessageBusInterface) *Handler {
	return &Handler{messageBus: messageBus}
}

func sendJSONRPCError(w http.ResponseWriter, jsonrpcErr *JSONRPCError, id interface{}) {
	response := JSONRPCResponse{
		JSONRPC: "2.0",
		Error:   jsonrpcErr,
		ID:      id,
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusBadRequest)
	json.NewEncoder(w).Encode(response)
}

type JSONRPCRequest struct {
	JSONRPC string        `json:"jsonrpc"`
	Method  string        `json:"method"`
	Params  []interface{} `json:"params"`
	ID      interface{}   `json:"id"`
}

type JSONRPCResponse struct {
	JSONRPC string        `json:"jsonrpc"`
	Result  interface{}   `json:"result,omitempty"`
	Error   *JSONRPCError `json:"error,omitempty"`
	ID      interface{}   `json:"id"`
}

type JSONRPCError struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data,omitempty"`
}

// Main JSON-RPC handler that routes to appropriate handlers
func (h *Handler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	var req JSONRPCRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		sendJSONRPCError(w, &JSONRPCError{
			Code:    -32700,
			Message: "Parse error",
		}, req.ID)
		return
	}

	var result interface{}
	var err error

	// REMEMBER THIS

	//  addresses aren't "registered" in the traditional sense. They simply exist
	//  once they're generated by a wallet, and they become
	//vVisible on the blockchain only when they're involved in transactions.

	// Check other JSON-RPC methods to make sure they're working as expected
	// Improve error handling to gracefully manage any future connection issues
	// Add features that utilize the blockchain data you're now able to retrieve

	// Only include core handlers
	switch req.Method {
	case "getBalance":
		// - Check wallet balances
		result, err = h.handleGetBalance(req.Params)
	case "getUTXO":
		// Get transaction inputs for creating new transactions
		result, err = h.handleGetUTXO(req.Params)
	case "getBlock":
		//  - Get block details
		result, err = h.handleGetBlock(req.Params)
	case "getBlockchainInfo":
		//  - Get high-level blockchain information
		result, err = h.handleGetBlockchainInfo(req.Params)
	case "getBlockTransactions":
		// - Get transactions in a block
		result, err = h.handleGetBlockTransactions(req.Params)
	case "submitSignedTransaction":
		//  - Send transactions
		result, err = h.handleSubmitSignedTransaction(req.Params)
	case "estimateGas":
		// - Calculate transaction fees
		result, err = h.handleEstimateGas(req.Params)
	case "stake":
		//  Main entry point for staking actions
		result, err = h.handleStaking(req.Params)
	case "getStakingInfo":
		// - Get staking status information
		result, err = h.handleGetStakingInfo(req.Params)
	default:
		sendJSONRPCError(w, &JSONRPCError{
			Code:    -32601,
			Message: "Method not found",
		}, req.ID)
		return
	}

	if err != nil {
		sendJSONRPCError(w, &JSONRPCError{
			Code:    -32603,
			Message: err.Error(),
		}, req.ID)
		return
	}

	response := JSONRPCResponse{
		JSONRPC: "2.0",
		Result:  result,
		ID:      req.ID,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// Method handlers using message bus
func (h *Handler) handleGetBalance(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("address parameter required")
	}

	address, ok := params[0].(string)
	if !ok {
		return nil, fmt.Errorf("invalid address parameter")
	}

	// Create response channel
	responseCh := make(chan types.Response)

	// Send message to get balance
	h.messageBus.Publish(types.Message{
		Type:       types.GetBalance,
		Data:       address,
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh
	if response.Error != nil {
		log.Printf("Error getting balance for address %s: %v", address, response.Error)
		if strings.Contains(response.Error.Error(), "wallet not found") {
			balance := int64(700000000)
			return struct {
				Balance        int64   `json:"balance"`
				BalanceThrylos float64 `json:"balanceThrylos"`
			}{
				Balance:        balance,
				BalanceThrylos: float64(balance) / 1e7,
			}, nil
		}
		return nil, fmt.Errorf("error getting balance: %v", response.Error)
	}
	balance, ok := response.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid balance data type")
	}
	if balance == 0 { // Add this check
		log.Printf("Balance is 0 for %s, returning default 70 THR", address)
		balance = int64(700000000)
	}
	return struct {
		Balance        int64   `json:"balance"`
		BalanceThrylos float64 `json:"balanceThrylos"`
	}{
		Balance:        balance,
		BalanceThrylos: float64(balance) / 1e7,
	}, nil
}

// handleGetUTXO now uses message bus
func (h *Handler) handleGetUTXO(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("address parameter required")
	}

	address, ok := params[0].(string)
	if !ok {
		return nil, fmt.Errorf("invalid address parameter")
	}

	log.Printf("Fetching UTXOs for address: %s", address)

	// Create response channel
	responseCh := make(chan types.Response)

	// Send message to get UTXOs
	h.messageBus.Publish(types.Message{
		Type: types.GetUTXOs,
		Data: types.UTXORequest{
			Address: address,
		},
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh

	if response.Error != nil {
		log.Printf("Error fetching UTXOs for address %s: %v", address, response.Error)
		return nil, fmt.Errorf("error fetching UTXOs: %v", response.Error)
	}

	// Convert response data to UTXOs
	utxos, ok := response.Data.([]types.UTXO)
	if !ok {
		return nil, fmt.Errorf("invalid UTXOs data type")
	}

	if len(utxos) == 0 {
		log.Printf("No UTXOs found for address: %s", address)
		return []interface{}{}, nil // Empty array instead of error for JSON-RPC
	}

	// Log UTXOs for debugging
	for i, utxo := range utxos {
		log.Printf("UTXO %d for address %s: {ID: %s, TransactionID: %s, Index: %d, Amount: %d, IsSpent: %v}",
			i, address, utxo.ID, utxo.TransactionID, utxo.Index, utxo.Amount, utxo.IsSpent)
	}

	return utxos, nil
}

// Add this method to your Handler struct in the network package

// handleGetBlock handles JSON-RPC requests to get block information
// Add this method to your Handler struct in the network package

// handleGetBlock handles JSON-RPC requests to get block information
func (h *Handler) handleGetBlock(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("block identifier required")
	}

	// Create response channel
	responseCh := make(chan types.Response)

	// Handle both string (hash) and number (height) parameters
	var messageData interface{}
	switch v := params[0].(type) {
	case string:
		messageData = v // block hash
	case float64:
		messageData = int32(v) // block height
	default:
		return nil, fmt.Errorf("invalid block identifier type")
	}

	// Send message to get block using ProcessBlock message type
	h.messageBus.Publish(types.Message{
		Type:       types.ProcessBlock, // Use existing ProcessBlock type
		Data:       messageData,
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh

	if response.Error != nil {
		return nil, fmt.Errorf("block not found: %v", response.Error)
	}

	// Convert response data to Block
	block, ok := response.Data.(*types.Block)
	if !ok {
		return nil, fmt.Errorf("invalid block data type")
	}

	if block.Transactions == nil {
		log.Printf("No transactions found in block %v", params[0])
	}

	return block, nil
}

// handleGetBlock now uses message bus
func (h *Handler) handleGetBlockchainInfo(params []interface{}) (interface{}, error) {
	// Create a single response channel
	infoCh := make(chan types.Response)

	// Request all blockchain info at once
	h.messageBus.Publish(types.Message{
		Type:       types.GetBlockchainInfo,
		Data:       nil, // No specific data needed
		ResponseCh: infoCh,
	})

	// Wait for response with timeout
	select {
	case resp := <-infoCh:
		if resp.Error != nil {
			return nil, resp.Error
		}
		return resp.Data, nil
	case <-time.After(5 * time.Second):
		return map[string]interface{}{
			"height":      0,
			"chainId":     "thrylos-testnet",
			"lastBlock":   "",
			"nodeCount":   0,
			"nodeVersion": "1.0.0",
			"isSyncing":   false,
		}, fmt.Errorf("timeout waiting for blockchain info")
	}
}

func (h *Handler) handleGetBlockTransactions(params []interface{}) (interface{}, error) {
	// Check if params exist
	if len(params) < 1 {
		return nil, fmt.Errorf("block ID parameter required")
	}

	// Extract blockID from params
	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format")
	}

	blockID, ok := reqData["blockId"].(string)
	if !ok {
		return nil, fmt.Errorf("blockId required")
	}

	// Create response channel
	blockCh := make(chan types.Response)

	// Send message to get block
	h.messageBus.Publish(types.Message{
		Type:       types.ProcessBlock,
		Data:       blockID,
		ResponseCh: blockCh,
	})

	// Wait for response
	blockResp := <-blockCh

	if blockResp.Error != nil {
		return nil, fmt.Errorf("block not found: %v", blockResp.Error)
	}

	// Convert response data to Block
	block, ok := blockResp.Data.(*types.Block)
	if !ok {
		return nil, fmt.Errorf("invalid block data type")
	}

	// Return transactions with additional metadata
	return map[string]interface{}{
		"blockId":          blockID,
		"transactionCount": len(block.Transactions),
		"transactions":     block.Transactions,
	}, nil
}

func deriveAddressFromPublicKey(publicKey []byte) (string, error) {
	// Convert public key bytes to 5-bit words for bech32 encoding
	words, err := bech32.ConvertBits(publicKey, 8, 5, true)
	if err != nil {
		return "", fmt.Errorf("failed to convert public key to 5-bit words: %v", err)
	}

	// Encode with your tl1 prefix (matching your frontend)
	address, err := bech32.Encode("tl1", words)
	if err != nil {
		return "", fmt.Errorf("failed to encode bech32 address: %v", err)
	}

	return address, nil
}

const MinTransactionAmount int64 = 1 * config.NanoPerThrylos // 1 THRYLOS in nanoTHRYLOS

func (h *Handler) handleSubmitSignedTransaction(params []interface{}) (interface{}, error) {
	// Check if params exist
	if len(params) < 1 {
		return nil, fmt.Errorf("transaction parameter required")
	}

	// Extract the request data
	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format")
	}

	// Extract and validate the main components
	payload, ok := reqData["payload"].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid payload format")
	}

	signature, ok := reqData["signature"].(string)
	if !ok {
		return nil, fmt.Errorf("invalid signature format")
	}

	publicKey, ok := reqData["publicKey"].(string)
	if !ok {
		return nil, fmt.Errorf("invalid publicKey format")
	}

	// Fast path validation
	sender, ok := payload["sender"].(string)
	if !ok {
		return nil, fmt.Errorf("invalid sender in payload")
	}

	// Critical validation
	validationDone := make(chan error, 1)
	var signatureBytes []byte
	var messageBytes []byte
	var publicKeyBytes []byte

	go func() {
		var err error
		// Get public key
		publicKeyBytes, err = base64.StdEncoding.DecodeString(publicKey)
		if err != nil {
			validationDone <- fmt.Errorf("invalid public key encoding: %v", err)
			return
		}

		// Verify the public key corresponds to the sender address
		derivedAddress, err := deriveAddressFromPublicKey(publicKeyBytes)
		if err != nil {
			validationDone <- fmt.Errorf("failed to derive address: %v", err)
			return
		}

		// Verify the sender address matches the derived address
		if derivedAddress != sender {
			validationDone <- fmt.Errorf("public key does not match sender address: derived=%s, claimed=%s",
				derivedAddress, sender)
			return
		}

		// Decode signature
		signatureBytes, err = base64.StdEncoding.DecodeString(signature)
		if err != nil {
			validationDone <- fmt.Errorf("invalid signature encoding: %v", err)
			return
		}

		// Marshal payload
		messageBytes, err = json.Marshal(payload)
		if err != nil {
			validationDone <- fmt.Errorf("failed to marshal payload: %v", err)
			return
		}

		// Verify signature
		pk := new(mldsa44.PublicKey)
		if err := pk.UnmarshalBinary(publicKeyBytes); err != nil {
			validationDone <- fmt.Errorf("failed to unmarshal public key: %v", err)
			return
		}

		// Verify signature using mldsa44
		if !mldsa44.Verify(pk, messageBytes, signatureBytes, nil) {
			validationDone <- fmt.Errorf("invalid signature")
			return
		}

		validationDone <- nil
	}()

	// Wait for validation with timeout
	select {
	case err := <-validationDone:
		if err != nil {
			return nil, err
		}
	case <-time.After(1 * time.Second):
		return nil, fmt.Errorf("validation timeout")
	}

	// Create transaction data
	// Create transaction data
	var transactionData types.Transaction
	transactionData.ID = payload["id"].(string)

	// Use the correct field name: SenderAddress instead of Sender
	senderAddr, err := address.FromString(sender)
	if err != nil {
		return nil, fmt.Errorf("invalid sender address: %v", err)
	}
	// Dereference the pointer to get the actual Address value
	transactionData.SenderAddress = *senderAddr

	// Process numeric fields
	if gasFeeFloat, ok := payload["gasfee"].(float64); ok {
		transactionData.GasFee = int(gasFeeFloat)
	} else {
		return nil, fmt.Errorf("invalid gasfee in payload")
	}

	if timestampFloat, ok := payload["timestamp"].(float64); ok {
		transactionData.Timestamp = int64(timestampFloat)
	} else {
		return nil, fmt.Errorf("invalid timestamp in payload")
	}

	// Process inputs/outputs
	if inputsData, ok := payload["inputs"].([]interface{}); ok {
		inputsJSON, err := json.Marshal(inputsData)
		if err != nil {
			return nil, fmt.Errorf("invalid inputs in payload: %v", err)
		}
		if err := json.Unmarshal(inputsJSON, &transactionData.Inputs); err != nil {
			return nil, fmt.Errorf("failed to parse inputs: %v", err)
		}
	}

	if outputsData, ok := payload["outputs"].([]interface{}); ok {
		outputsJSON, err := json.Marshal(outputsData)
		if err != nil {
			return nil, fmt.Errorf("invalid outputs in payload: %v", err)
		}
		if err := json.Unmarshal(outputsJSON, &transactionData.Outputs); err != nil {
			return nil, fmt.Errorf("failed to parse outputs: %v", err)
		}
	}

	// Create proper Thrylos transaction and set signature
	thrylosTx := convertToThrylosTransaction(&transactionData)
	if thrylosTx == nil {
		return nil, fmt.Errorf("failed to convert transaction data")
	}
	thrylosTx.Signature = signatureBytes

	log.Printf("[TX Handler] Created transaction with ID: %s", thrylosTx.GetId())

	// Create response channel for transaction processing
	processTxCh := make(chan types.Response)

	// Send message to process transaction
	h.messageBus.Publish(types.Message{
		Type:       types.ProcessTransaction,
		Data:       thrylosTx,
		ResponseCh: processTxCh,
	})

	// Wait for processing response with timeout
	var processTxResponse types.Response
	select {
	case processTxResponse = <-processTxCh:
		if processTxResponse.Error != nil {
			return nil, fmt.Errorf("failed to process transaction: %v", processTxResponse.Error)
		}
	case <-time.After(10 * time.Second):
		return nil, fmt.Errorf("transaction processing timeout")
	}

	// Handle balance updates and broadcasting in background
	// Update the goroutine with the correct field name
	// Handle balance updates in background
	go func() {
		addresses := make(map[string]bool)

		// Use SenderAddress.String() instead of Sender
		senderAddrStr := transactionData.SenderAddress.String()
		addresses[senderAddrStr] = true

		for _, output := range transactionData.Outputs {
			addresses[output.OwnerAddress] = true
		}

		time.Sleep(500 * time.Millisecond)

		for i := 0; i < 3; i++ {
			for address := range addresses {
				balanceCh := make(chan types.Response)
				h.messageBus.Publish(types.Message{
					Type:       types.GetBalance,
					Data:       address,
					ResponseCh: balanceCh,
				})

				// Process balance response
				balanceResp := <-balanceCh
				if balanceResp.Error == nil {
					if balance, ok := balanceResp.Data.(int64); ok {
						// Notify balance update
						h.messageBus.Publish(types.Message{
							Type: types.UpdateState,
							Data: types.UpdateStateRequest{
								Address: address,
								Balance: balance, // Use int64 directly
							},
							ResponseCh: nil, // No response needed
						})
					}
				}
				time.Sleep(200 * time.Millisecond)
			}
		}
	}()

	// Return success response
	return struct {
		Message string `json:"message"`
		Status  string `json:"status"`
		TxID    string `json:"txId"`
	}{
		Message: fmt.Sprintf("Transaction %s submitted successfully", transactionData.ID),
		Status:  "pending",
		TxID:    transactionData.ID,
	}, nil
}

// Helper function to convert types.Transaction to thrylos.Transaction
func convertToThrylosTransaction(tx *types.Transaction) *thrylos.Transaction {
	if tx == nil {
		return nil
	}

	// Create new Thrylos transaction
	thrylosTx := &thrylos.Transaction{
		Id:        tx.ID,                     // Matches ID field
		Sender:    tx.SenderAddress.String(), // Convert address.Address to string
		Timestamp: tx.Timestamp,
		Status:    "pending",
		Gasfee:    int32(tx.GasFee), // Convert int to int32
	}

	// Convert inputs
	thrylosTx.PreviousTxIds = make([]string, len(tx.Inputs))
	for i, input := range tx.Inputs {
		thrylosTx.PreviousTxIds[i] = input.TransactionID // Adjust based on actual field name
	}

	// Convert outputs
	thrylosTx.Outputs = make([]*thrylos.UTXO, len(tx.Outputs))
	for i, output := range tx.Outputs {
		thrylosTx.Outputs[i] = &thrylos.UTXO{
			OwnerAddress:  output.OwnerAddress,
			Amount:        int64(output.Amount), // Convert amount.Amount to int64
			Index:         int32(output.Index),  // Convert int to int32
			TransactionId: tx.ID,                // Matches ID field
		}
	}

	return thrylosTx
}

func (h *Handler) handleEstimateGas(params []interface{}) (interface{}, error) {
	// Log the incoming request
	log.Printf("estimateGas JSON-RPC method called")

	// Check if params exist
	if len(params) < 1 {
		return nil, fmt.Errorf("dataSize parameter required")
	}

	// Extract dataSize from params
	dataSizeFloat, ok := params[0].(float64)
	if !ok {
		return nil, fmt.Errorf("invalid dataSize parameter: must be a number")
	}

	// Convert float64 to int
	dataSize := int(dataSizeFloat)

	// Create response channel
	responseCh := make(chan types.Response)

	// Send message to estimate gas
	h.messageBus.Publish(types.Message{
		Type: types.EstimateGas, // Now defined
		Data: map[string]interface{}{
			"dataSize": dataSize,
			"txType":   0, // Default transaction type
		},
		ResponseCh: responseCh,
	})

	// Wait for response
	response := <-responseCh

	if response.Error != nil {
		return nil, fmt.Errorf("error estimating gas: %v", response.Error)
	}

	// Convert response data to gas fee
	gas, ok := response.Data.(int)
	if !ok {
		return nil, fmt.Errorf("invalid gas fee data type")
	}

	// Log the estimation
	log.Printf("Gas fee estimate calculated: %d for data size: %d", gas, dataSize)

	// Return structured response
	return struct {
		GasFee     int    `json:"gasFee"`
		GasFeeUnit string `json:"gasFeeUnit"`
	}{
		GasFee:     gas,
		GasFeeUnit: "nanoTHRYLOS",
	}, nil
}

// Main handler for staking operations
func (h *Handler) handleStaking(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("parameters required")
	}

	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format")
	}

	// Extract operation type
	operation, ok := reqData["operation"].(string)
	if !ok {
		return nil, fmt.Errorf("operation field required")
	}

	switch operation {
	case "stake":
		return h.handleStakeOperation(reqData)
	case "validate":
		return h.handleValidateStakeOperation(reqData)
	default:
		return nil, fmt.Errorf("unknown operation: %s", operation)
	}
}

func (h *Handler) handleStakeOperation(reqData map[string]interface{}) (interface{}, error) {
	// Extract required fields
	userAddress, ok := reqData["userAddress"].(string)
	if !ok {
		return nil, fmt.Errorf("userAddress required")
	}

	amountFloat, ok := reqData["amount"].(float64)
	if !ok {
		return nil, fmt.Errorf("amount required")
	}
	amount := int64(amountFloat)

	validatorAddress, ok := reqData["validatorAddress"].(string)
	if !ok {
		return nil, fmt.Errorf("validatorAddress required")
	}

	// Create response channels for various operations
	minStakeCh := make(chan types.Response)
	validatorExistsCh := make(chan types.Response)
	balanceCh := make(chan types.Response)
	createStakeCh := make(chan types.Response)

	// Get minimum stake amount
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       "minStakeAmount",
		ResponseCh: minStakeCh,
	})

	// Check if validator exists and is active
	h.messageBus.Publish(types.Message{
		Type: types.ValidateValidator,
		Data: map[string]interface{}{
			"address": validatorAddress,
		},
		ResponseCh: validatorExistsCh,
	})

	// Get user balance
	h.messageBus.Publish(types.Message{
		Type:       types.GetBalance,
		Data:       userAddress,
		ResponseCh: balanceCh,
	})

	// Wait for responses
	minStakeResp := <-minStakeCh
	validatorResp := <-validatorExistsCh
	balanceResp := <-balanceCh

	// Process responses
	if minStakeResp.Error != nil {
		return nil, fmt.Errorf("failed to get minimum stake: %v", minStakeResp.Error)
	}
	minStake, ok := minStakeResp.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid minimum stake data type")
	}

	// Validate minimum stake
	if amount < minStake {
		return nil, fmt.Errorf("stake amount must be at least %d THRYLOS", minStake/1e7)
	}

	// Validate validator exists and is active
	if validatorResp.Error != nil || validatorResp.Data == nil {
		return nil, fmt.Errorf("invalid validator address")
	}
	validatorExists, ok := validatorResp.Data.(bool)
	if !ok || !validatorExists {
		return nil, fmt.Errorf("validator does not exist or is not active")
	}

	// Check user's balance
	if balanceResp.Error != nil {
		return nil, fmt.Errorf("failed to get balance: %v", balanceResp.Error)
	}
	balance, ok := balanceResp.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid balance data type")
	}

	if balance < amount+1000 { // Including gas fee
		return nil, fmt.Errorf("insufficient balance for staking")
	}

	// Create stake record via message bus
	h.messageBus.Publish(types.Message{
		Type: types.CreateStake,
		Data: map[string]interface{}{
			"userAddress": userAddress,
			"amount":      amount,
			"validator":   validatorAddress,
		},
		ResponseCh: createStakeCh,
	})

	// Wait for stake creation response
	createStakeResp := <-createStakeCh
	if createStakeResp.Error != nil {
		return nil, fmt.Errorf("failed to create stake: %v", createStakeResp.Error)
	}

	// Get stake record from response
	stakeRecord, ok := createStakeResp.Data.(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid stake record data type")
	}

	// Create staking transaction ID
	stakingTxId := fmt.Sprintf("stake-%s-%d", userAddress, time.Now().UnixNano())

	// Get inflation rate for response
	effectiveRateCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       "effectiveRate",
		ResponseCh: effectiveRateCh,
	})
	effectiveRateResp := <-effectiveRateCh
	effectiveRate := "4.8%"
	if effectiveRateResp.Error == nil {
		if rate, ok := effectiveRateResp.Data.(float64); ok {
			effectiveRate = fmt.Sprintf("%.2f%%", rate)
		}
	}

	// Get staking pool info for last reward time
	poolInfoCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetPoolStats,
		Data:       nil,
		ResponseCh: poolInfoCh,
	})
	poolInfoResp := <-poolInfoCh

	// Extract last reward time and calculate next reward time
	lastRewardTime := time.Now().Unix()
	if poolInfoResp.Error == nil {
		if poolInfo, ok := poolInfoResp.Data.(map[string]interface{}); ok {
			if lrt, ok := poolInfo["lastRewardTime"].(int64); ok {
				lastRewardTime = lrt
			}
		}
	}
	nextRewardTime := lastRewardTime + (24 * 3600) // 24 hours in seconds

	// Get active validators count
	validatorsCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetValidators,
		Data:       nil,
		ResponseCh: validatorsCh,
	})
	validatorsResp := <-validatorsCh
	activeValidatorsCount := 1
	if validatorsResp.Error == nil {
		if validators, ok := validatorsResp.Data.([]interface{}); ok {
			activeValidatorsCount = len(validators)
		}
	}

	// Format response
	return map[string]interface{}{
		"message": "Stake created successfully",
		"stake": map[string]interface{}{
			"amount":         float64(amount) / 1e7,
			"amountRaw":      amount,
			"startTime":      stakeRecord["startTime"],
			"isActive":       stakeRecord["isActive"],
			"validatorRole":  stakeRecord["validatorRole"],
			"lastRewardTime": lastRewardTime,
		},
		"transactionId": stakingTxId,
		"stakingInfo": map[string]interface{}{
			"yearlyReward":         "4.8M",
			"effectiveRate":        effectiveRate,
			"minStakeAmount":       float64(minStake) / 1e7,
			"nextRewardTime":       nextRewardTime,
			"rewardInterval":       "24h",
			"activeValidators":     activeValidatorsCount,
			"estimatedDailyReward": 4800000.0 / 365.0 / float64(activeValidatorsCount) / 1e7,
		},
	}, nil
}

func (h *Handler) handleValidateStakeOperation(reqData map[string]interface{}) (interface{}, error) {
	amountFloat, ok := reqData["amount"].(float64)
	if !ok {
		return nil, fmt.Errorf("amount required")
	}
	amount := int64(amountFloat)

	// Get minimum stake amount
	minStakeCh := make(chan types.Response)
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       "minStakeAmount",
		ResponseCh: minStakeCh,
	})

	// Wait for response
	minStakeResp := <-minStakeCh
	if minStakeResp.Error != nil {
		return nil, fmt.Errorf("failed to get minimum stake: %v", minStakeResp.Error)
	}

	minStake, ok := minStakeResp.Data.(int64)
	if !ok {
		return nil, fmt.Errorf("invalid minimum stake data type")
	}

	if amount < minStake {
		return nil, fmt.Errorf("minimum stake is %d THR", minStake/1e7)
	}

	return map[string]interface{}{
		"valid": true,
	}, nil
}

func (h *Handler) handleGetStakingInfo(params []interface{}) (interface{}, error) {
	if len(params) < 1 {
		return nil, fmt.Errorf("address parameter required")
	}

	// Extract address
	reqData, ok := params[0].(map[string]interface{})
	if !ok {
		return nil, fmt.Errorf("invalid request format")
	}

	userAddress, ok := reqData["address"].(string)
	if !ok {
		return nil, fmt.Errorf("address parameter required")
	}

	// Create response channels
	stakingInfoCh := make(chan types.Response)
	poolInfoCh := make(chan types.Response)
	validatorCh := make(chan types.Response)

	// Send requests in parallel
	h.messageBus.Publish(types.Message{
		Type:       types.GetStakingStats,
		Data:       userAddress,
		ResponseCh: stakingInfoCh,
	})

	h.messageBus.Publish(types.Message{
		Type:       types.GetPoolStats,
		Data:       nil,
		ResponseCh: poolInfoCh,
	})

	h.messageBus.Publish(types.Message{
		Type: types.IsValidator,
		Data: map[string]interface{}{
			"address": userAddress,
		},
		ResponseCh: validatorCh,
	})

	// Collect responses
	stakingInfoResp := <-stakingInfoCh
	poolInfoResp := <-poolInfoCh
	validatorResp := <-validatorCh

	// Initialize with default values
	totalStaked := int64(0)
	totalRewards := int64(0)
	isValidator := false
	activeStakes := make([]*types.Stake, 0)
	currentTime := time.Now().Unix()
	nextRewardTime := currentTime + (24 * 3600)
	stakingPool := map[string]interface{}{
		"minStakeAmount": int64(10000000000), // 1000 THR in nano
		"totalStaked":    int64(0),
		"lastRewardTime": currentTime - (12 * 3600), // 12 hours ago
	}

	// Process staking info response
	if stakingInfoResp.Error == nil {
		if info, ok := stakingInfoResp.Data.(map[string]interface{}); ok {
			if ts, ok := info["totalStaked"].(int64); ok {
				totalStaked = ts
			} else if tsMap, ok := info["totalStaked"].(map[string]interface{}); ok {
				if nano, ok := tsMap["nano"].(int64); ok {
					totalStaked = nano
				}
			}

			if tr, ok := info["totalRewards"].(int64); ok {
				totalRewards = tr
			} else if trMap, ok := info["totalRewards"].(map[string]interface{}); ok {
				if nano, ok := trMap["nano"].(int64); ok {
					totalRewards = nano
				}
			}

			if stakes, ok := info["activeStakes"].([]types.Stake); ok {
				for _, stake := range stakes {
					activeStakes = append(activeStakes, &stake)
				}
			}
		}
	}

	// Process pool info response
	if poolInfoResp.Error == nil {
		if pool, ok := poolInfoResp.Data.(map[string]interface{}); ok {
			if minStake, ok := pool["minStakeAmount"].(int64); ok {
				stakingPool["minStakeAmount"] = minStake
			}

			if totalPoolStake, ok := pool["totalStaked"].(int64); ok {
				stakingPool["totalStaked"] = totalPoolStake
			}

			if lastRewardTime, ok := pool["lastRewardTime"].(int64); ok {
				stakingPool["lastRewardTime"] = lastRewardTime
				nextRewardTime = lastRewardTime + (24 * 3600)
			}
		}
	}

	// Process validator response
	if validatorResp.Error == nil {
		if v, ok := validatorResp.Data.(bool); ok {
			isValidator = v
		}
	}

	// Calculate time until next reward
	lastRewardTime, _ := stakingPool["lastRewardTime"].(int64)
	timeUntilNextReward := (lastRewardTime + 24*3600) - currentTime
	if timeUntilNextReward < 0 {
		timeUntilNextReward = 0
	}

	// Return structured response
	return map[string]interface{}{
		"address":     userAddress,
		"isValidator": isValidator,
		"staking": map[string]interface{}{
			"totalStaked": map[string]interface{}{
				"thrylos": float64(totalStaked) / 1e7,
				"nano":    totalStaked,
			},
			"totalRewards": map[string]interface{}{
				"thrylos": float64(totalRewards) / 1e7,
				"nano":    totalRewards,
			},
			"activeStakesCount": len(activeStakes),
			"activeStakes":      activeStakes,
			"nextRewardTime":    nextRewardTime,
		},
		"stakingPool": map[string]interface{}{
			"minStakeAmount": map[string]interface{}{
				"thrylos": float64(stakingPool["minStakeAmount"].(int64)) / 1e7,
				"nano":    stakingPool["minStakeAmount"].(int64),
			},
			"totalStaked": map[string]interface{}{
				"thrylos": float64(stakingPool["totalStaked"].(int64)) / 1e7,
				"nano":    stakingPool["totalStaked"].(int64),
			},
			"rewardSchedule": map[string]interface{}{
				"interval":             "24h",
				"lastRewardTime":       lastRewardTime,
				"nextRewardTime":       nextRewardTime,
				"timeUntilNextReward":  timeUntilNextReward,
				"estimatedDailyReward": float64(4800000) / 365.0 / 10.0 / 1e7, // Assuming 10 validators
			},
			"rewardInfo": map[string]interface{}{
				"yearlyReward":       "4.8M",
				"effectiveRate":      "4.8%",
				"rewardDistribution": "Daily",
			},
		},
	}, nil
}

/// Get Balance test curl
// curl -X POST http://localhost:50051/ \
//   -H "Content-Type: application/json" \
//   -d '{"jsonrpc":"2.0","method":"getBalance","params":["tl1839b4955945b1607"],"id":1}' \
//   -v
