package main

import (
	"bytes"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"log"
	"os" // <<<--- Import the 'os' package

	"github.com/cloudflare/circl/sign/mldsa/mldsa44"
)

func main() {
	// --- Inputs from Your Logs ---
	seedBase64 := "iMEH6XZ1O2kTLaIn5Z2fvsLmQpBUO61Er1kIZPQZtlk="
	payloadString := `{"gasfee":1000000,"id":"tx19635101d0b7a4872","inputs":[{"Index":0,"TransactionID":"balance-1744646970635"}],"outputs":[{"Amount":20000000,"Index":0,"OwnerAddress":"tl1a9gvmt2qvdsejtx4xjm8ufamd9w32p73jfyrm0"},{"Amount":79000000,"Index":1,"OwnerAddress":"tl1nvzdz4stm5uxfsak5zlv8tyymnwgtuj4ez0fk7"}],"sender":"tl1nvzdz4stm5uxfsak5zlv8tyymnwgtuj4ez0fk7","timestamp":1744646970635}`

	fmt.Println("--- Cross-Verification Start ---")

	// --- Read Signature from File ---
	sigFileBytes, err := os.ReadFile("signature.txt")
	if err != nil {
		log.Fatalf("Failed to read signature.txt: %v", err)
	}
	// Trim whitespace just in case & convert to string
	signatureFromWasmBase64 := string(bytes.TrimSpace(sigFileBytes))
	if len(signatureFromWasmBase64) == 0 {
		log.Fatalf("signature.txt appears to be empty")
	}
	log.Printf("Read %d bytes from signature.txt", len(signatureFromWasmBase64))
	// You can optionally add: log.Printf("Signature string from file (first/last 10): %s...%s", signatureFromWasmBase64[:10], signatureFromWasmBase64[len(signatureFromWasmBase64)-10:])
	// --- End Read Signature ---

	// 1. Decode Seed
	seedBytes, err := base64.StdEncoding.DecodeString(seedBase64)
	if err != nil {
		log.Fatalf("Failed to decode seed: %v", err)
	}
	if len(seedBytes) != mldsa44.SeedSize {
		log.Fatalf("Invalid seed size: got %d, want %d", len(seedBytes), mldsa44.SeedSize)
	}
	var seedArray [mldsa44.SeedSize]byte
	copy(seedArray[:], seedBytes)
	log.Printf("Decoded Seed OK (Size: %d)", len(seedBytes))

	// 2. Generate Private Key from Seed using native Go CIRCL
	_, sk := mldsa44.NewKeyFromSeed(&seedArray)
	if sk == nil {
		log.Fatalf("Failed to generate private key from seed using Go CIRCL")
	}
	log.Println("Generated Private Key from seed using Go CIRCL OK")

	// 3. Get Payload Bytes
	payloadBytes := []byte(payloadString)
	log.Printf("Using Payload Bytes (len %d)", len(payloadBytes))

	// 4. Sign using Go's mldsa44.SignTo
	generatedSigBytes := make([]byte, mldsa44.SignatureSize)
	err = mldsa44.SignTo(sk, payloadBytes, nil, false, generatedSigBytes)
	if err != nil {
		log.Fatalf("Go mldsa44.SignTo failed: %v", err)
	}
	log.Printf("Generated Signature using Go CIRCL OK (len %d)", len(generatedSigBytes))

	// 5. Decode the Signature Read from the File
	expectedSigBytes, err := base64.StdEncoding.DecodeString(signatureFromWasmBase64) // Decode string read from file
	if err != nil {
		// If this still fails, the content of signature.txt is WRONG.
		log.Fatalf("Failed to decode signature read from file: %v", err)
	}
	if len(expectedSigBytes) != mldsa44.SignatureSize {
		log.Fatalf("Decoded signature from file has wrong size: got %d, want %d", len(expectedSigBytes), mldsa44.SignatureSize)
	}
	log.Printf("Decoded Signature from file OK (len %d)", len(expectedSigBytes))

	// 6. Compare the Signatures
	if bytes.Equal(generatedSigBytes, expectedSigBytes) {
		fmt.Println("\n✅✅✅ SUCCESS: Signature generated by Go MATCHES the signature from WASM! ✅✅✅")
		fmt.Println("This suggests the signing process in WASM is likely correct.")
		fmt.Println("The 'invalid signature' error likely originates from the backend's Verify step or environment.")
	} else {
		fmt.Println("\n❌❌❌ FAILURE: Signature generated by Go DOES NOT MATCH the signature from WASM! ❌❌❌")
		fmt.Println("This strongly suggests the problem lies within the WASM signing implementation or environment.")
		fmt.Printf("Go Sig Hex:   %s\n", hex.EncodeToString(generatedSigBytes))
		fmt.Printf("WASM Sig Hex: %s\n", hex.EncodeToString(expectedSigBytes))
	}
	fmt.Println("--- Cross-Verification End ---")
}
